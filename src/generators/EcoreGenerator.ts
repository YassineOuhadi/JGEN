import fs from 'fs';
import { CompositeGeneratorNode, NL, toString } from 'langium';
import path from 'path';
import { Enum, Entity, Attribute, Project, Literal, Relationship } from '../language-server/generated/ast';
import { extractDestinationAndName } from '../cli/cli-util';

let enumLiteralCounter = 0;
let model : Project;

export function generateEcore(project: Project, filePath: string, destination: string | undefined): string {
    model = project;
    const data = extractDestinationAndName(filePath, destination);
    const generatedFilePath = path.join(data.destination, `${data.name}.ecore`);

    const fileNode = new CompositeGeneratorNode();
    fileNode.append(
        generateFileHeader(),
        generateEPackage(model),
    );

    if (!fs.existsSync(data.destination)) {
        fs.mkdirSync(data.destination, { recursive: true });
    }

    fs.writeFileSync(generatedFilePath, toString(fileNode));
    return generatedFilePath;
}

function generateFileHeader(): CompositeGeneratorNode {
    return new CompositeGeneratorNode(
        "// Automatically generated by Jgen, please report any bugs or improvements as issues at https://github.com/YassineOuhadi/JGEN",
        NL
    );
}

function generateEPackage(model: Project): CompositeGeneratorNode {
    const ePackageNode = new CompositeGeneratorNode(
        `<?xml version="1.0" encoding="UTF-8"?>`,
        NL,
        `<ecore:EPackage xmi:version="2.0"
             xmlns:xmi="http://www.omg.org/XMI"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore"
             nsURI="http://www.example.org/jgen" 
             nsPrefix="${model.name}"
             name="${model.name}">`,
        ...(model.structuralComponents.map(generateEcoreElement)),
        NL,
        `</ecore:EPackage>`
    );

    return ePackageNode;
}

function generateEcoreElement(element: any): CompositeGeneratorNode {
    switch (element.$type) {
        case "Enum":
            return generateEnum(element as Enum);
        case "Entity":
            return generateEClass(element as Entity);
        default:
            return new CompositeGeneratorNode(); // Return an empty node for other types
    }

}

function generateEnum(e: Enum): CompositeGeneratorNode {
    const enumNode = new CompositeGeneratorNode(
        NL,
        `<eClassifiers xsi:type="ecore:EEnum" name="${e.name}">`,
        ...(e.literals || []).map(generateEnumLiteral),
        NL,
        `</eClassifiers>`
    );

    return enumNode;
}

function generateEnumLiteral(literal: Literal): string {
    return `\n<eLiterals name="${literal.name}" value="${enumLiteralCounter++}"/>`;
}

function generateEClass(entity: Entity): CompositeGeneratorNode {
    const eClassNode = new CompositeGeneratorNode(
        NL,
        `<eClassifiers xsi:type="ecore:EClass" name="${entity.name}">`,
        ...(entity.attributes || []).map(generateEAttribute),
        NL, 
        ...((model.structuralComponents.filter(component => component.$type === 'Relationship') as Relationship[]).filter(component => component.from.ref?.name === entity.name).map(generateEReference)),
        NL,
        `</eClassifiers>`
    );

    return eClassNode;
}

function generateEAttribute(field: Attribute): string {
    return `\n<eStructuralFeatures xsi:type="ecore:EAttribute" name="${field.name}" eType=${field.enumType ? `"#//${field.enumType.ref?.name}"` : generateEType(field.type!)}/>`;
}

function generateEType(type: string): string {
    switch (type) {
        case "Integer":
            return `"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt"`;
        case "Long":
            return `"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//ELong"`;
        case "String":
            return `"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"`;
        case "Boolean":
            return `"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EBoolean"`;
        case "Float":
            return `"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDouble"`;
        default:
            return "";
    }
}

function generateEReference(relationship: Relationship): string {
    return `<eStructuralFeatures xsi:type="ecore:EReference" name="${relationship.type === "ManyToOne" ? (relationship.to.ref?.name)?.toLowerCase() : (relationship.to.ref?.name)?.toLowerCase()+"s" }" eType="#//${relationship.to.ref?.name}" eOpposite="#//${relationship.to.ref?.name}/${relationship.type !== "ManyToOne" ? (relationship.from.ref?.name)?.toLowerCase() : (relationship.from.ref?.name)?.toLowerCase()+"s" }" lowerBound="${relationship.type !== "ManyToOne" ? '-1' : '1' }" upperBound="${relationship.type !== "ManyToOne" ? '-1' : '1' }"/>`;
}



// function generateEReference(relationship: Relationship): string {
//     return `<eStructuralFeatures xsi:type="ecore:EReference" 
//     name=${relationship.to.ref?.name+"s|null?"} 
//     ${vreference.LowerBound ? " lowerBound=\"" + vreference.LowerBound + "\"" : ""}
//     ${vreference.UpperBound ? " upperBound=\"" + vreference.UpperBound + "\"" : ""} 
//     eType=${generateETypeReference(vreference.VType)}
//     />`;
// }